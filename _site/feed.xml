<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
        <channel>
            <title></title>
            <description></description>      
            <link>http://localhost:4000</link>
            <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
                
                    
                        <item>
                            <title>Understanding Raft - Part 2 (Raft leaders, logs, and safety)</title>
                            <description>&lt;blockquote&gt;
  &lt;p&gt;This post is a continuation in the series I wrote about Raft, the first part of which is &lt;a href=&quot;2020/05/08/understanding-raft-consensus.html&quot;&gt;here&lt;/a&gt;. This post focuses on what underlies leader election, log replication, and Raft safety. Enjoy!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;leaders-and-leader-election&quot;&gt;Leaders and leader election&lt;/h2&gt;
&lt;p&gt;The Raft protocol requires a single node (called the &lt;strong&gt;Leader&lt;/strong&gt;) to direct other nodes on how they should change their respective states of the world. There can only be one leader at a time - Raft maintains a representation of time called a &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt;. This term only changes in special situations, like when a node attempts to become a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;.
When a Raft cluster starts, there are no leaders and one needs to be chosen through a process called &lt;strong&gt;Leader Election&lt;/strong&gt; before the cluster can start responding to requests.&lt;/p&gt;

&lt;h3 id=&quot;how-does-the-leader-election-process-work&quot;&gt;How does the leader election process work?&lt;/h3&gt;
&lt;p&gt;A node starts the leader election process by designating itself to be a &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt;, incrementing its term, voting for itself, and requesting the votes of other nodes in the Raft cluster using &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestVote&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are a few ways that a node can exit &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt; state:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If the &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt; node receives a majority of votes within some configurable time period of the election starting, it becomes the leader.&lt;/li&gt;
  &lt;li&gt;If the &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt; node doesn’t receive a majority of votes within some configurable time period of the election starting (and it hasn’t heard from another leader, as in the case below), the node restarts the election (including incrementing its term and and sending out &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestVote&lt;/code&gt; communications again).&lt;/li&gt;
  &lt;li&gt;If the &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt; (Node A) hears from a different peer (Node B) who claims to be &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; for a term greater than or equal to the term that Node A is on, Node A stops its election, sets its term to Node B’s, enters the &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; state, and begins listening for updates from the &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once a node becomes a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;, it begins sending communications in the form of &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; (discussed more in the next section) messages to all other peers, and will continue trying to do so unless it hears about a different &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; with a higher term (you may be wondering how Raft ensures that a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; with an out of date state of the world doesn’t somehow acquire a higher term, but that topic is covered in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Safety&lt;/code&gt; section).&lt;/p&gt;

&lt;p&gt;To allow Raft to recover from a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; failing (maybe because of an ethernet unplugging scenario), an up to date &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; can kick off an election.&lt;/p&gt;

&lt;p&gt;&lt;label for=&quot;raft-states&quot; class=&quot;margin-toggle&quot;&gt;⊕&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;raft-states&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;marginnote&quot;&gt;&lt;img class=&quot;fullwidth&quot; src=&quot;https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FMivsh%2FNcIg3LfB_V.png?alt=media&amp;amp;token=28bc65f4-5a48-43ab-99cb-3b504392a356&quot; /&gt;&lt;br /&gt;Raft States&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I found the visualization in the margin (from the original Raft paper) to be helpful for thinking about the ways that a node can transition between the three possible states of &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;raft-logs-and-replication&quot;&gt;Raft logs and replication&lt;/h2&gt;

&lt;h3 id=&quot;what-is-an-appendentries-request-and-what-information-does-it-contain&quot;&gt;What is an AppendEntries request and what information does it contain?&lt;/h3&gt;
&lt;p&gt;As mentioned above, &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; nodes periodically send &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; messages to &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; nodes to let the &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt;s know that there is still an active &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;. 
These &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; calls also serve the purpose of helping to update out of date &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt;s with correct data to store in their logs.
The information that the leader supplies in the calls is as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader's&lt;/code&gt; current term -&lt;/strong&gt; as mentioned in the &lt;strong&gt;Leaders and leader election&lt;/strong&gt; section, if a node is a &lt;code class=&quot;highlighter-rouge&quot;&gt;Candidate&lt;/code&gt; or a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;, hearing about a new or existing leader might require the node to take some action (like giving up on an election or stepping down as a &lt;em&gt;Leader&lt;/em&gt;).&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Log entries&lt;/strong&gt; (represented as an array) that the &lt;strong&gt;Leader&lt;/strong&gt; wants to propagate to peers, along with data about the &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader's&lt;/code&gt; log that will help the &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; make a decision about what to do with the new entries. In particular, the &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; sends data about the log entry that immediately preceded the entries it is sending. Because the data pertains to the previous log entry, the names of the variables are &lt;strong&gt;previousLogIndex&lt;/strong&gt; and &lt;strong&gt;previousLogTerm&lt;/strong&gt;.  &lt;label for=&quot;leader-log&quot; class=&quot;margin-toggle&quot;&gt;⊕&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;leader-log&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;marginnote&quot;&gt;&lt;img class=&quot;fullwidth&quot; src=&quot;https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FMivsh%2FJ67QQC2tnw.png?alt=media&amp;amp;token=85f3bb55-1a92-4c85-bf89-804728cca996&quot; /&gt;&lt;br /&gt;Leader log&lt;/span&gt; For an example of how these variables are assigned, consider a Leader’s log as shown in the margin. If the leader wanted to update the follower with entries that are in positions 9 through 10, it would include those in the &lt;strong&gt;log entries&lt;/strong&gt; section of the &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; call, setting &lt;strong&gt;previousLogIndex&lt;/strong&gt; to 8 and &lt;strong&gt;previousLogTerm&lt;/strong&gt; to 6.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader's&lt;/code&gt; &lt;strong&gt;commitIndex&lt;/strong&gt;: this is where the idea of &lt;strong&gt;committing&lt;/strong&gt; from the earlier part of this guide comes into play.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-happens-when-a-peer-receives-an-appendentries-request&quot;&gt;What happens when a peer receives an AppendEntries request?&lt;/h3&gt;
&lt;p&gt;Once a peer receives an &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; request from a leader, it evaluates whether it will need to update its state, then responds with its current term as well as whether it successfully processed the request:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;If the receiving node has a greater term than the sending node&lt;/strong&gt;, the receiving node ignores the &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; request and immediately communicates to the sending node that the request failed. This has the effect of causing the sending node to step down as a leader. A situation where this could arise is when a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; is disconnected from the network, a new election succeeds (with a new term and Leader), then the old Leader is reconnected. Because Raft only allows one leader at a time, the old one should step down.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;If the receiving node has an equal term as the sending node, a few conditions need to be evaluated:&lt;/strong&gt;
Firstly, if the receiving node is not a &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt;, it should immediately transition to being one. This behavior serves to notify candidates for the term that a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; has been elected, as well as guarding against the existence of two &lt;code class=&quot;highlighter-rouge&quot;&gt;Leaders&lt;/code&gt;. Hitting this condition does not cause the &lt;code class=&quot;highlighter-rouge&quot;&gt;AppendEntries&lt;/code&gt; request to return.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Once it has been checked that the receiving and sending nodes have the same term, we need to make sure that their logs match.&lt;/strong&gt; This check is performed by looking at the &lt;strong&gt;previousLogIndex&lt;/strong&gt; and &lt;strong&gt;previousLogTerm&lt;/strong&gt; of the sending node and comparing to the receiving node’s log. 
As part of performing this check, a few scenarios arise.
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;In the match case&lt;/strong&gt;, the &lt;strong&gt;previousLogIndex&lt;/strong&gt; and &lt;strong&gt;previousLogTerm&lt;/strong&gt; of the sending node match the entry in the receiving node’s log, meaning that everything is up to date! If this is true, the receiving node can add the received entries to its log. The receiving node also checks whether the &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; has a newer commit index (meaning that the receiving node is able to update its commit index and apply messages that will affect its state)&lt;/li&gt;
          &lt;li&gt;If the log for a &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; is not up to date, the Leader will keep decrementing the &lt;strong&gt;previousLogIndex&lt;/strong&gt; for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; and keep retrying the request until the logs match (the match case above is true) or it has been determined that all entries in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Follower&lt;/code&gt; need to be replace&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;raft-safety&quot;&gt;Raft Safety&lt;/h2&gt;
&lt;p&gt;At the core of Raft are guarantees about safety that make sure that data in the log isn’t corrupted or lost. For example, imagine that a &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; starts coordinating changes to the log, does so successfully, then goes offline. While the existing &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; is offline, a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; is elected and the system continues updating the log. If the old &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt; were to come back online, how can we make sure that it isn’t able to rewind the system’s log?&lt;/p&gt;

&lt;p&gt;To account for this situation (and all of the edge cases that can occur in distributed systems), Raft aims to implement several ideas around Safety. A few of these we’ve already touched on (descriptions are from Figure 3 of the original Raft paper):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Election Safety:&lt;/strong&gt; “There can at most be one leader at a time.” Discussed in &lt;strong&gt;Leaders and leader election&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Leader Append-Only:&lt;/strong&gt; “a leader never overwrites or deletes entries in its log; it only appends new entries.” The leader never mutates it’s internal logs. Discussed in &lt;strong&gt;Raft logs and replication&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Log Matching&lt;/strong&gt;: “if two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index.” If the leader doesn’t have logs that match followers, the leader will rewind the follower’s log entries, then send over the correct data. Discussed in &lt;strong&gt;Raft logs and replication&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The other important ideas around Raft Safety are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Leader Completeness&lt;/strong&gt;: “if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms”. The gist of this principle is to ensure that a leader has all log entries that should be stored permanently (&lt;strong&gt;committed&lt;/strong&gt;) by the system. To make the idea of Leader Completeness concrete, imagine a situation where a key-value store performs a put and then a delete - if the put operation was replicated, but the delete happened in a higher term and is not in the log of the leader, the state of the world will be incorrect, as the delete will not be processed. To ensure that leaders aren’t elected with stale logs, a node that receives a &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestVote&lt;/code&gt; must check that the sender has a log where the last entry is of a greater term or of the same term and of a higher index. If the receiver determines that neither of those conditions is true, then it rejects the request.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;State Machine Safety&lt;/strong&gt;:  “if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index.” The gist of this principle is to ensure that a leader applies entries from its log in the correct order. To make the idea of State Machine Safety concrete, imagine a situation where a key-value store performs a put and then a delete (both of which are stored in individual log entries). If the put operation was applied, then the delete operation was applied, every other node must perform the same sequence of applications. A more detailed explanation of the proof is available in the Raft paper.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you’ve made it to the end, thanks for following along and until next time!&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Raft Paper - &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&quot;&gt;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                            <pubDate>Sat, 09 May 2020 00:00:00 -0700</pubDate>
                            <link>http://localhost:4000/2020/05/09/understanding-raft-consensus-part-2.html</link>
                            <guid isPermaLink="true">http://localhost:4000/2020/05/09/understanding-raft-consensus-part-2.html</guid>
                        </item>
                    
                
                    
                        <item>
                            <title>Understanding Raft Consensus  - Part 1</title>
                            <description>&lt;p&gt;Recently I was digging deeper into &lt;a href=&quot;https://raft.github.io/&quot;&gt;Raft&lt;/a&gt;, an important algorithm in the field of distributed systems. Raft is a &lt;strong&gt;consensus algorithm&lt;/strong&gt;, meaning that it is designed to facilitate a set of computers agreeing on a state of the world (more on exactly how the state of the world is represented later), even when communications between the computers in the set are interrupted (say for example, by someone accidentally unplugging a network cable that connects some of the nodes to the majority).&lt;/p&gt;

&lt;p&gt;The problem of reliably storing a state of the world across many computers, keeping the state in sync, and scaling this functionality is required in a number of modern systems - for example, Kubernetes stores all cluster data in &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/components/#etcd&quot;&gt;etcd&lt;/a&gt;, a key-value store library that uses Raft under the hood.&lt;/p&gt;

&lt;p&gt;Given how important (and nuanced) the algorithm is, I wanted to attempt to boil it down to its simplest possible components first, then followup with a deeper dive.&lt;/p&gt;

&lt;p&gt;It’s worth noting that there are a wealth of resources about Raft. Some of my favorites are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;a href=&quot;https://www.youtube-nocookie.com/embed/YbZ3zDzDnrw&quot;&gt;video explanation of Raft&lt;/a&gt; created by the authors of the paper.&lt;/li&gt;
  &lt;li&gt;A &lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot;&gt;visualization&lt;/a&gt; of how Raft works&lt;/li&gt;
  &lt;li&gt;An excellent walkthrough of a Raft implementation (with documentation) by Eli Bendersky, &lt;a href=&quot;https://eli.thegreenplace.net/2020/implementing-raft-part-0-introduction/&quot;&gt;available here&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html&quot;&gt;Lab 2 from MIT’s 6.824 course&lt;/a&gt;, which comes with a full test suite and guidance on how to implement the algorithm in manageable chunks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;whats-novel-about-raft&quot;&gt;What’s novel about Raft?&lt;/h2&gt;
&lt;p&gt;As mentioned above, Raft is an algorithm designed to help computers synchronize state through a process called &lt;strong&gt;consensus&lt;/strong&gt;, although it was not the first system designed to do so.&lt;/p&gt;

&lt;p&gt;A main difference between Raft and previous consensus algorithms was the desire to optimize the design with simplicity in mind - a trait that the authors thought was missing from existing research.&lt;/p&gt;

&lt;p&gt;In particular, Raft aimed to improve on &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf&quot;&gt;Paxos&lt;/a&gt;, a groundbreaking but (the authors of Raft argue) somewhat complicated set of ideas for achieving distributed consensus.&lt;/p&gt;

&lt;p&gt;To attempt to quantify the complexity of Paxos, the Raft authors conducted a survey at NSDI, one of the top conferences for distributed systems academics:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;In an informal survey of attendees at NSDI 2012, we found few people who were comfortable with Paxos, even among seasoned researchers. We struggled with Paxos ourselves; we were not able to understand the complete protocol until after reading several simplified explanations and designing our own alternative protocol, a process that took almost a year.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Other engineers also documented difficultes productionizing Paxos. Google implemented a system based off of Paxos called &lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf&quot;&gt;Chubby&lt;/a&gt; and &lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/class/08w-dsi/chandra07paxos.pdf&quot;&gt;documented the “algorithmic and engineering challenges … encountered in moving Paxos from theory to practice&lt;/a&gt;. In their paper they note that, “Despite the existing literature on the subject [Paxos], building a production system turned out to be a non-trivial task for a variety of reasons”.&lt;/p&gt;

&lt;p&gt;From the above commentary, it might seem that Paxos is a terribly complicated and near-impossible set of ideas to implement, although this isn’t entirely true. Some have argued that Raft trades off understability for a performance hit, although it is unclear whether this is true given the latest &lt;a href=&quot;https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/performance.md&quot;&gt;etcd benchmarks&lt;/a&gt;. For further reading on Paxos vs Raft, &lt;a href=&quot;https://arxiv.org/pdf/2004.05074.pdf&quot;&gt;this paper&lt;/a&gt; is an interesting read.&lt;/p&gt;

&lt;h2 id=&quot;at-a-high-level-how-does-raft-work&quot;&gt;At a high level, how does Raft work?&lt;/h2&gt;

&lt;p&gt;Now that we have some context about the &lt;em&gt;why?&lt;/em&gt; of Raft, there are a few high level points that are important to understand about Raft:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The purpose of the Raft algorithm&lt;/strong&gt; is to replicate a state of the world across a cluster of computers. Rather than sending single messages that contain the complete state of the world, Raft consensus involves a log of incremental changes, represented internally as an array of commands. A key value store can be used as a more concrete example of representing the state of world with in this way - the current state of the world in a KV store contains the keys and values for those keys, but each &lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt; is a single change that leads to that state. These individual changes can be stored in an append-only log format (the 2nd part of this series goes into more detail on how the log component of Raft works in the &lt;strong&gt;Raft logs and replication&lt;/strong&gt; section).&lt;/li&gt;
  &lt;li&gt;Raft peers communicate using &lt;strong&gt;well-defined messages&lt;/strong&gt;. There are several defined in the original paper, but the two essential ones are:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;RequestVote&lt;/strong&gt;: a message used by Raft to elect a peer that coordinates updating the state of the world. More info in the &lt;strong&gt;Leaders and leader election&lt;/strong&gt; section of Part 2.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;AppendEntries&lt;/strong&gt;: a message used by Raft to allow peers to communicate about changes to the state of the world. More details of how the state is replicated in the &lt;strong&gt;Raft logs and replication&lt;/strong&gt; section.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Members of a Raft cluster are called peers and can be in one of three states&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Leader:&lt;/strong&gt; the node that coordinates other nodes in the cluster to update their state. All changes to the state of the world flow through the &lt;code class=&quot;highlighter-rouge&quot;&gt;Leader&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Candidate&lt;/strong&gt;: the node is vying to become a leader&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Follower&lt;/strong&gt;: the node is receiving instructions about how to update its state from a leader&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;Leader&lt;/strong&gt; manages updates to the state of the world by taking two types of actions: &lt;strong&gt;committing&lt;/strong&gt; and &lt;strong&gt;applying&lt;/strong&gt;. The leader &lt;strong&gt;commits&lt;/strong&gt; to an index in its log (called a &lt;strong&gt;commitIndex&lt;/strong&gt;) once a majority of the nodes in the network have acknowledged that they’ve also stored the entry successfully. When a node moves its &lt;strong&gt;commitIndex&lt;/strong&gt; forward in the log (the &lt;strong&gt;commitIndex&lt;/strong&gt; can only move forward, never backward!), it &lt;strong&gt;applies&lt;/strong&gt; (processes) entries in the log up to where it is committed. The ideas of committing and applying ensure that a Leader doesn’t update its state of the world until it is guaranteed that the log that led to that state is impossible to change - more info on the “impossible to change” idea in the next article’s &lt;strong&gt;Safety&lt;/strong&gt; section.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With that context, we can start breaking Raft down into more concrete sections that try to answer questions about the protocol:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Leaders and leader election&lt;/strong&gt; covers how updates to a Raft
cluster’s state are coordinated: Which computer is coordinating
changes to the state of the world, how does this computer
coordinate with other computers in the Raft cluster, and for how
long does the computer coordinate?&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Raft logs and replication&lt;/strong&gt; covers the mechanism of state being
replicated: How does the state of the world get propagated to other
computers in the cluster? How do other computers get new information about the state of the world if they were disconnected, but are now back online (someone unplugged the computer’s ethernet cable)?&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Safety&lt;/strong&gt; covers how Raft guards against edge cases that could corrupt the state of the world: How do we make sure that a computer with an old state of the world does not accidentally overwrite another computer’s updated state of the world?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given that this article is already fairly lengthy, I saved the three topics outlined above for the second part of the series, &lt;a href=&quot;/2020/05/09/understanding-raft-consensus-part-2.html&quot;&gt;available here&lt;/a&gt;.&lt;/p&gt;
</description>
                            <pubDate>Fri, 08 May 2020 00:00:00 -0700</pubDate>
                            <link>http://localhost:4000/2020/05/08/understanding-raft-consensus.html</link>
                            <guid isPermaLink="true">http://localhost:4000/2020/05/08/understanding-raft-consensus.html</guid>
                        </item>
                    
                
                    
                        <item>
                            <title>Understanding Google&amp;#8217;s File System</title>
                            <description>&lt;p&gt;Today I read &lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf&quot;&gt;the original paper&lt;/a&gt; about the Google File System (GFS), a system that provided the storage layer for many of Google’s applications in the company’s early days. The original implementation has reportedly been replaced by a newer version called Colossus, but reading about the original approach was still illuminating and I thought I’d do a quick write up about it.&lt;/p&gt;

&lt;h3 id=&quot;why-iswas-gfs-such-a-big-deal&quot;&gt;Why is/was GFS such a big deal?&lt;/h3&gt;

&lt;p&gt;The original paper was published in 2003 at SOSP (Symposium on Operating Systems Principles - one of, if not the, best conferences for operating systems research).&lt;/p&gt;

&lt;p&gt;GFS made it onto the program because of how revolutionary it was at the time - the accompanying paper detailed how Google had successfully implemented academic ideas of weak consistency and reliance on a single master controller (more on this later) at tremendous scale in an industry application.&lt;/p&gt;

&lt;p&gt;The ultimate goal of GFS was to provide a replicated storage layer (redundant copies of data are kept across many machines) across the commodity level machines in a Google datacenter. The original motivation for developing such a system was to power batch jobs, although the system eventually powered other projects.&lt;/p&gt;

&lt;p&gt;Because GFS was designed for batch jobs, it primarily optimized for appending to, rather than modifying, files. Users of the program were generally writing large files out at once rather than making modifications to specific parts of a file.&lt;/p&gt;

&lt;h3 id=&quot;what-are-the-abstractions-that-power-gfs&quot;&gt;What are the abstractions that power GFS?&lt;/h3&gt;

&lt;p&gt;At the core of GFS is a concept called &lt;strong&gt;chunks&lt;/strong&gt;. Chunks are used to split up files into fixed-size 64MB segments that are then replicated around the datacenter &lt;a href=&quot;#footnotes&quot;&gt;†&lt;/a&gt;. Chunks are referred to by &lt;strong&gt;chunk handles&lt;/strong&gt;, basically unique ids for a chunk. Splitting a large file into many chunks, then replicating those chunks across many machines accomplished two goals: improving performance (as there could now be many readers and writers of a single file), and allowing huge files to exist behind a simple abstraction.&lt;/p&gt;

&lt;p&gt;To make the idea of how this abstraction works more concrete, imagine using a library to open a file on a disk. Behind the scenes, that library now goes out and fetches all of the different pieces of the file you requested from computers all around your datacenter, then provides a transparent way to interact with the stitched together data &lt;a href=&quot;#footnotes&quot;&gt;†&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The aforementioned library (called by your user program, the Client) performs fetching and writing operations by interacting with several components of GFS:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Master&lt;/strong&gt;: The master has a few responsibilties. To start, it is the first point of contact for a client when they want to interact with GFS. In addition to that function, the master is also responsible for communicating with a set of &lt;strong&gt;chunk servers&lt;/strong&gt; that host chunks. To perform its functions, the master stores a few tables in RAM:
    &lt;ul&gt;
      &lt;li&gt;A mapping from filenames to &lt;strong&gt;chunk handles&lt;/strong&gt; (chunk handles are basically IDs for chunks).&lt;/li&gt;
      &lt;li&gt;A mapping from &lt;strong&gt;chunk handles&lt;/strong&gt; to a list of the machines that the chunk is on, versioning information about the chunk (a piece of data to help with managing multiple writes to the same chunk), and two pieces of information related to managing writes to that chunk - the primary and the lease. I’ll cover the primary and the lease in the next section.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Chunk Server&lt;/strong&gt;: Chunk servers handle work around writing to and reading from disk. A client starts talking to them after being told to do so by the master.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-does-writing-and-reading-to-gfs-work&quot;&gt;How does writing and reading to GFS work?&lt;/h3&gt;

&lt;h4 id=&quot;reading-from-gfs&quot;&gt;Reading from GFS&lt;/h4&gt;
&lt;p&gt;To read a file to GFS, a client says to the master, “I would like to read this byte offset in this file”, where the file looks like a regular file system path.&lt;/p&gt;

&lt;p&gt;The master then receives the request from the client and calculates which chunk corresponds to the associated file and byte offset. Using the chunk handle of the calculated chunk, the master then gets the list of chunk servers that store the aforementioned chunk and provides it to the client. The client then chooses a chunk server, contacting it with the chunk and offset it wants, then is provided with the requested data.&lt;/p&gt;

&lt;p&gt;Along the way, the client also caches information about the chunk and the chunkservers it can find that chunk on if it needs to rerequest the chunk.&lt;/p&gt;

&lt;h4 id=&quot;writing-to-gfs&quot;&gt;Writing to GFS&lt;/h4&gt;

&lt;p&gt;Writing (in this case, appending) to files in GFS is significantly more complicated than reading from GFS.&lt;/p&gt;

&lt;p&gt;To start a client, asks the master for a specific file’s last chunk (the end of the file is necessary because we are appending). The master then checks its tables for information on that chunk, using the returned chunk handle (the chunk handle is essentially the ID of the chunk).&lt;/p&gt;

&lt;p&gt;The master then inspects two pieces of information that it is storing about each chunk - the primary and lease fields.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;primary&lt;/strong&gt; is a reference to a chunk server that has been assigned to coordinate writes among chunk servers. This assignment is short lived, and is governed by the expiration of the &lt;strong&gt;lease&lt;/strong&gt;. When the lease runs out, the master can assign a new chunk server to coordinate writes.&lt;/p&gt;

&lt;p&gt;If the chunk that a client requests does not have a &lt;strong&gt;primary&lt;/strong&gt; assigned, the master assigns one, and increments the version of the data. Incrementing the version number allows the master to keep track of which data is the most recent. If the chunk already has a primary, this step is skipped.&lt;/p&gt;

&lt;p&gt;The next step is to transmit information about the primary and secondaries (chunk servers that have the chunk, but aren’t the primary) to the client. From there, the client sends the data it wants to write to the respective chunk servers. After all chunk servers have the data, the client tells the primary to write it. The primary chunk server chooses a byte offset in the chunk (whatever the end of the file is), and sends it to all of the secondaries, after which all of them perform the right.&lt;/p&gt;

&lt;p&gt;If the primary and all secondaries write, the client receives a success! If not all secondaries write, the client receives a failure, at which point it needs to recontact the master and repeat the process from the beginning.&lt;/p&gt;

&lt;h3 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;I &lt;a href=&quot;https://queue.acm.org/detail.cfm?id=1594206&quot;&gt;found an interview&lt;/a&gt; with one of the engineers who worked on GFS to be fairly interesting. GFS was very successful for the applications it was designed for and reached wide adoption within Google.&lt;/p&gt;

&lt;p&gt;Unfortunately, it didn’t scale as well to new use cases for a few reasons. First off, the system used a single master process to store of chunk servers in addition to other metadata. Having all of this information in RAM on a single machine only went so far.&lt;/p&gt;

&lt;p&gt;Another issue that GFS ran into was in storing small files. For example, if a user wanted to store many files smaller than the chunk size, the master needed to store an entry for each file, and allocate the full chunk size on disk. Google ended up working on other systems and making tweaks to GFS to solve this problem (in particular, one of the systems that is discusses is BigTable).&lt;/p&gt;

&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a name=&quot;#1&quot;&gt;[1]&lt;/a&gt; Google’s new storage system would try to decrease the chunk size for reasons that I talk about at the end of this post.&lt;/li&gt;
  &lt;li&gt;&lt;a name=&quot;#2&quot;&gt;[2]&lt;/a&gt; Whether the data is actually stitched together or not is somewhat of an implementation detail&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;references&quot;&gt;References:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[1] &lt;a href=&quot;http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf&quot;&gt;GFS paper&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[2] &lt;a href=&quot;https://www.youtube.com/watch?v=EpIgvowZr00&amp;amp;feature=emb_title&quot;&gt;MIT Distributed Systems lecture on GFS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[3] &lt;a href=&quot;https://cs.stanford.edu/~matei/courses/2015/6.S897/slides/gfs.pdf&quot;&gt;Talk about GFS from Firas Abuzaid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                            <pubDate>Sun, 22 Mar 2020 00:00:00 -0700</pubDate>
                            <link>http://localhost:4000/2020/03/22/understanding-googles-file-system.html</link>
                            <guid isPermaLink="true">http://localhost:4000/2020/03/22/understanding-googles-file-system.html</guid>
                        </item>
                    
                
                    
                        <item>
                            <title>2019 year in review &amp; looking ahead in 2020</title>
                            <description>&lt;p&gt;Last year I &lt;a href=&quot;https://www.micahlerner.com/post/2019/01/13/NewBlog.html&quot;&gt;wrote up&lt;/a&gt; a few of my goals for learning, and I wanted to repeat the exercise for this year. Planning for last year, even in rough terms, helped me sketch out a path and think about what I wanted to explore. I ended up writing and publishing 4 articles over the course of the year, much better than 2018. Also, talking about what I wanted to learn led to some encouraging words from friends and mentors, and prompted discussions where I shared what I had been learning with people who were interested.&lt;/p&gt;

&lt;h2 id=&quot;what-went-well&quot;&gt;What went well&lt;/h2&gt;
&lt;p&gt;I did a few things right when it came to my learning goals in 2019:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Morning schedule&lt;/strong&gt;: I became a morning person after a few weeks of trying to be productive after work wasn’t working out as well as I would have hoped. Before making the change, I would sometimes get home drained of the energy I was expecting to spend learning new things. I eventually settled into waking up early, working out, learning for a few hours, then starting my work day as everyone else was. The new schedule also allowed me to work as late as needed without having to feel stressed about fitting in the time I was yearning for.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Following my interests/passions&lt;/strong&gt;: I really dove into subjects that I found myself excited about, even if they were off the rough path that I was expecting to follow. For example, I didn’t plan on bug bounty hunting at all, even though I spent a much of December doing it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-could-have-gone-better&quot;&gt;What could have gone better&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Sharing with more frequency&lt;/strong&gt;: I followed my interests in a relatively unstructured way (the proverbial “going down the rabbithole”), but I didn’t write much as I was going along. I think I didn’t end up writing frequently because of two factors: I wasn’t actively thinking about topics to write about, and some of the things I was learning didn’t seem like they would be interesting if shared piecemeal. Actively thinking about writing, as well as keeping the “ship early, ship often” mindset top-of-mind, will not only result in me writing more, but also will help me interest more people in what I’m writing about.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;More building&lt;/strong&gt;: I feel that I overweighted absorbing new information over the last year, and underweighted building things with that information. With some of the things that I want to explore this year, I think I’ll have a chance to equalize how I spend my time between building and consuming.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Better goal setting&lt;/strong&gt;: I didn’t write as much as much as I wanted to (although still more than the year before), and I didn’t start a few of the things I wanted to try out (for example, CryptoPals and Microcorruption). Learning new things shouldn’t be a job, but setting better goals would be helpful for prioritizing and focusing my learning.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-i-want-to-learn-more-about-in-2020&quot;&gt;What I want to learn more about in 2020&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Machine Learning / Deep Learning&lt;/strong&gt;: ML is top of mind for me again this year, although I didn’t spend as much time on it in 2019. I’ve decided to explore in a few directions, and I will write more about that soon. I’d also like to compete in at least one machine-learning-centric competion this year. Ideally this would be with dataset I’m excited about, like one from satellites. I’m also excited to read ML research and attempt to write about it, similar to what &lt;a href=&quot;https://blog.acolyer.org/&quot;&gt;The Morning Paper&lt;/a&gt; does with Distributed Systems research.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Math&lt;/strong&gt;: I’ve been wanting to deepen my math knowledge for a while and have a few ideas about how to do so. I’m motivated to expand my expertise in Math because it seems fun (and useful while I dig into ML). I’d like to flex a few math muscles (calculus, linear algebra, and statistics) I haven’t flexed in a bit, read a &lt;a href=&quot;https://jeremykun.com/2018/12/01/a-programmers-introduction-to-mathematics/&quot;&gt;Programmer’s Introduction to Math&lt;/a&gt;, and try out &lt;a href=&quot;https://github.com/fastai/numerical-linear-algebra/blob/master/README.md&quot;&gt;Computational Linear Algebra&lt;/a&gt;. Beyond that, we’ll see where the journey takes me. Thankfully, there are a few good resources from &lt;a href=&quot;https://news.ycombinator.com/item?id=8996024&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;http://steve-yegge.blogspot.com/2006/03/math-for-programmers.html&quot;&gt;Steve Yegge&lt;/a&gt; (ex-Google engineer) on good places to start with respect to self-learning math.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Distributed Systems&lt;/strong&gt; - I’ve been reading &lt;a href=&quot;https://blog.acolyer.org/&quot;&gt;The Morning Paper&lt;/a&gt; for a while and quite like the format that the author follows for summarizing research. Reading about how large-scale systems are designed is fascinating, and Adrian provided good tips for finding cutting edge research in this field (among others). Reading papers and talking about them would also give me a great opportunity to write.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Mandarin&lt;/strong&gt;: I’ve been learning Mandarin! It’s fun and challenging. I’d like to practice Mandarin 30 minutes every day for the rest of 2020.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first three areas I’m interested in are hard to set goals for, although with the motivation of shipping early and often, I’d like to write at least one new post a month about whatever topic I’m currently in the weeds with. This goal strikes the right balance between being a forcing function while remaining flexible enough to let me explore whatever rabbithole I’m currently in.&lt;/p&gt;

&lt;p&gt;As for learning Mandarin, thankfully the apps I’m using (Duolingo and LingoDeer) track progress fairly well, although depending on how much time I have, I might end up taking an in-person class as well…we’ll see.&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
                            <pubDate>Sun, 01 Mar 2020 00:00:00 -0800</pubDate>
                            <link>http://localhost:4000/yearly/review/2020/03/01/looking-ahead-in-2020.html</link>
                            <guid isPermaLink="true">http://localhost:4000/yearly/review/2020/03/01/looking-ahead-in-2020.html</guid>
                        </item>
                    
                
                    
                        <item>
                            <title>A new year of learning and writing</title>
                            <description>&lt;p&gt;In the spirit of the new year, I am going to attempt to write more often and
post most of my writing on my personal blog (with the occasional share to Medium). While I have attempted to write in the past, I am more hopeful that this time will be different, and that the habit will stick.&lt;/p&gt;

&lt;p&gt;One of the things that I am excited to write about this year is my personal growth as an engineer. While there are many factors that go into growing as an engineer (mentoring other engineers, communicating clearly with others, etc), a primary component is a desire for continuous learning. I feel lucky to have both the time and energy to hone a skill that I enjoy, and I am looking forward to deepening my technical knowledge in 2019.&lt;/p&gt;

&lt;p&gt;On this thread, there are several topics I am eager to dive into greater depth on this year:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Operating systems and computer networking&lt;/strong&gt;: I am fascinated by the guts of computers, and engineers like &lt;a href=&quot;https://jvns.ca/&quot;&gt;Julia Evans&lt;/a&gt; inspire me to learn (and write!) more about the systems that I interact with. Her blog is excellent, and I aspire to document my learning similarly.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Crypto (where Crypto means cryptography, not ICOs)&lt;/strong&gt;: I’m also excited to learn more about cryptography and crypto engineering. In particular, I would like to sink my teeth into &lt;a href=&quot;https://cryptopals.com/sets/1&quot;&gt;Cryptopals&lt;/a&gt;. Other engineers &lt;a href=&quot;https://blog.pinboard.in/2013/04/the_matasano_crypto_challenges/&quot;&gt;highly recommend it&lt;/a&gt;, and solutions are widely available. While it is unlikely that I become a full-blown security engineer, I believe that grokking low-level cryptographic primitives will be generally useful.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Network Security&lt;/strong&gt;: Along the trend of deepening my understanding of crypto, operating systems, and networking, I would like to participate in at least one CTF (Capture The Flag) this year, and complete at least one of the wargames out there (like &lt;a href=&quot;http://overthewire.org/wargames/&quot;&gt;OverTheWire&lt;/a&gt;, which I have started, but not completed).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Machine learning&lt;/strong&gt;: While I took a Computational Neuroscience class in college, the course mostly focused on theory. The tooling was much different, and two of the major frameworks in use today weren’t even released yet (PyTorch and Tensorflow)! I want to learn more of the mathematical fundamentals behind machine learning and build at least one application of my new knowledge.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While these learning goals seem lofty, I hope that this post is one that I can look at a year from now and feel positively about what I’ve learned. Onward and upward.&lt;/p&gt;

</description>
                            <pubDate>Sat, 12 Jan 2019 16:00:00 -0800</pubDate>
                            <link>http://localhost:4000/post/2019/01/12/NewBlog.html</link>
                            <guid isPermaLink="true">http://localhost:4000/post/2019/01/12/NewBlog.html</guid>
                        </item>
                    
                
        </channel>
</rss>
